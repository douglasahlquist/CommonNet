/*   @(#)  MyRuntime.java  2002-02-04
*
*  Copyright(C) 2002, All Rights Reserved.
*  Ahlquist.com
*  516 Suisse Drive
*  San Jose, California 95123
*  U.S.A.
*
*  This document contains information proprietary and confidential to
*  Ahlquist.com, which is either copyrighted or which a
*  patent has been applied and/or protected by trade secret laws.
*
*  This document, or any parts thereof, may not be used, disclosed,
*  or reproduced in any form, by any method, or for any purpose without
*  the express written permission of Ahlquist.com.
*
*
*/

package com.ahlquist.common.util;

import org.apache.log4j.Logger;

/**
 * MyRuntime is a singleton object that encapsulates a few context-specific
 * operations. This encapsulation allows the classes in the
 * com.ahlquist.common.util package to be shared by different areas of the
 *  system (server, gui, external api, etc.)
 * <p>
 * 
 * It includes only those methods which must be implemented differently in
 * different areas.
 * <p>
 *
 * MyRuntime is a concrete class that defines the default implementation.
 * <p>
 *
 * Any area which desires alternative behavior must subclass MyRuntime (in its
 * <i>own</i> package) and may override methods. setInstance must then be called
 * at or near the beginning of that area's main.
 */
public class MyRuntime extends MyObject {
	final static Logger logger = Logger.getLogger(MyRuntime.class);

	/** singleton */
	private static MyRuntime runtime = null;

	/** Use the specified runtime rather than the default */
	public static synchronized void setInstance(MyRuntime runtime) {
		MyRuntime.runtime = runtime;
	}

	/** returns the current runtime object */
	public static MyRuntime getInstance() {
		if (runtime == null) {
			createDefaultInstance();
		}

		return (runtime);
	}

	/** create and set the default implementation of MyRuntime */
	private static synchronized void createDefaultInstance() {
		if (runtime == null) {
			runtime = new MyRuntime();
		}
	}

	// IMPORTANT!
	// We will put as little functionality in this class as is
	// absolutely necessary.

	/**
	 * Log.println(String) has been called. The default implementation does
	 * nothing.
	 * 
	 * @see com.ahlquist.server.lib.ServerRuntime
	 */
	public void appendLog(String text) {
	}

	//TODO:DKA
	/*
	public void escalateError(MyError error) {
		if (error.shouldNotify()) {
			throw new RuntimeException(error.toString());
		}

		// the default implementation here is intended for the jsp-based
		// GUI applications.
		// see also com.ahlquist.server.lib.ServerRuntime
	}
	*/

	//TODO:DKA
	//public void addContext(MyError error) {
	//}

	/**
	 * Updates Name-Value Pairs in the trace GUI. Default does nothing.
	 * 
	 * @see ServerRuntime
	 * @see com.ahlquist.common.util.Debug
	 */
	public void updateNameValue(Logger log, String name, String value) {
	}

	/**
	 * Removes any name/value paris generated by the specified debug module.
	 * @see com.ahlquist.common.util.Debug
	 */
	public synchronized void clearNameValues(Logger log) {
	}

	public void exit() {
		//TODO: DKA should also send email to the sysadmin
		exit("Critical Error Occured Exiting Application!!!");
	}

	public void exit(String message) {
		Log.fEnableTraceOutput = false;

		if (message.length() == 0) {
			logger.debug("Exit VM: " + new java.util.Date());
		} else {
			logger.debug("Exit VM: " + message + "\t" + new java.util.Date());
		}

		System.exit(0);
		logger.debug("VM should have exited!");
	}

	public boolean isServer() {
		return (false);
	}

	public void addContext(MyError myError) {
		logger.error("addContext called.  method NOT implemented!");
		//TODO: DKA need to add functionality
	}

	public void escalateError(MyError myError) {
		logger.error("escalateError called.  method NOT implemented!");
		// TODO DKA need to add functionality
		
	}

}
